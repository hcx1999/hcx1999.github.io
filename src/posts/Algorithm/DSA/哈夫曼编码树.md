---
title: 哈夫曼编码树
icon: pen-to-square

pageInfo: false
contributors: false
editLink: false
prev: false
next: false
footer: false
---

第一次使用指针构建数据结构，有一个非常大的bug就是priority_queue中的q.top()返回的是一个固定的地址的类，因此不能直接使用，应该new一个之后再使用。还有，尽量少的直接定义用node型变量而是用node* nd = new node来避免重复使用地址。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cstring>
#include <typeinfo>

using namespace std;

struct node{
	int val = 0;
	node *fa = nullptr;
	node *son1 = nullptr;
	node *son2 = nullptr;
	bool operator < (const node& tmp) const{
		return val > tmp.val;
	}
};
priority_queue<node> q;

int dfs(node* rt, int d){
	if(rt->son1 == nullptr && rt->son2 == nullptr){
		return (rt->val) * d;
	}
	return dfs(rt->son1, d+1) + 
		   dfs(rt->son2, d+1);
}

void test(){
	int* a, b;
	cout<<typeid(a).name()<<' '<<typeid(b).name()<<endl;
}

node* deepCopy(const node x){
	node* y;
	y->val = x.val;y->son1 = x.son1;y->son2 = x.son2;y->fa = x.fa;
	return y;
}

int main(){
//	test();
	int T;cin>>T;while(T--){
		int n;cin>>n;
		while(!q.empty()) q.pop();
		while(n--){
			int temp;cin>>temp;
			node* tmp = new node;tmp->val = temp;
			q.push(*tmp);
		}
		while(q.size() > 1){
			node* x1 = new node(q.top());q.pop();
			node* x2 = new node(q.top());q.pop();
			node* y = new node;y->val = x1->val + x2->val;
			y->son1 = x1; y->son2 = x2;
			x1->fa = x2->fa = y;
			q.push(*y);
		}
		node* rt = new node(q.top());q.pop();
//		cout<<rt->val<<' '<<rt->son1->val<<' '<<rt->son2->val<<' '<<rt->son1->son1->val<<' '<<rt->son1->son2->val<<endl<<endl;
		cout<<dfs(rt, 0)<<endl;
	}
	return 0;
}
```

