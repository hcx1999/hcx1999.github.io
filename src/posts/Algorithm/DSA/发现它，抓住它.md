---
title: 发现它，抓住它
icon: pen-to-square

pageInfo: false
contributors: false
editLink: false
prev: false
next: false
footer: false
---

做法1：对森林中每棵并查集建立双向的enemy关系，每次合并相当于是合并最多4棵并查集（即a所在的、a敌对的、b所在的、b敌对的）。每个enemy只存在与树根中，其他节点中的enemy是无效量，从而保证唯一性。注意节点的enemy随时可能失去树根身份，所以使用时必须套上`find(en[x])`。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

int fa[200000], en[200000];

int f(int x){
	if(x == fa[x]) return x;
	return fa[x] = f(fa[x]);
}

int main(){
	int T;cin>>T;
	while(T--){
		int N, M; cin>>N>>M;
		for(int i = 1; i <= N; ++i) {fa[i] = i;en[i] = 0;}
		for(int i = 1; i <= M; ++i){
			char ch;int x, y;cin>>ch>>x>>y;
			x = f(x); y = f(y);
			if(ch == 'A'){
				if(x == y) cout<<"In the same gang."<<endl;
				else if(f(en[x]) == y || f(en[y]) == x) cout<<"In different gangs."<<endl;
				else cout<<"Not sure yet."<<endl;
			}
			else{
				if(f(en[x]) == y && f(en[y]) == x) continue;
				if(f(en[x]) == 0 && f(en[y]) == 0) {en[x] = y; en[y] = x;continue;}
				if(f(en[x])) fa[y] = f(en[x]);
				if(f(en[y])) fa[x] = f(en[y]);
			}
		}
	}
	return 0;
}
```

做法2：带权并查集，每次路径压缩时更新节点权值。注意路径压缩可以保证m次操作的最坏时间复杂度为$O(mlogn)$，所以不需要担心额外进行操作会导致复杂度变高。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

int fa[200000], en[200000];

int f(int x){
	if(x == fa[x]) return x;
	return fa[x] = f(fa[x]);
}

int main(){
	int T;cin>>T;
	while(T--){
		int N, M; cin>>N>>M;
		for(int i = 1; i <= N; ++i) {fa[i] = i;en[i] = 0;}
		for(int i = 1; i <= M; ++i){
			char ch;int x, y;cin>>ch>>x>>y;
			x = f(x); y = f(y);
			if(ch == 'A'){
				if(x == y) cout<<"In the same gang."<<endl;
				else if(f(en[x]) == y || f(en[y]) == x) cout<<"In different gangs."<<endl;
				else cout<<"Not sure yet."<<endl;
			}
			else{
				if(f(en[x]) == y && f(en[y]) == x) continue;
				if(f(en[x]) == 0 && f(en[y]) == 0) {en[x] = y; en[y] = x;continue;}
				if(f(en[x])) fa[y] = f(en[x]);
				if(f(en[y])) fa[x] = f(en[y]);
			}
		}
	}
	return 0;
}
```